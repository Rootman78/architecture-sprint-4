# Архитектурное решение по логированию

## Собираемые логи

Необходимо собирать логи с типом INFO

Считаю что логирование с типом INFO необходимо производить в следующих ключевых точках системы: 
1. Shop API. Необходимо создавать запись, когда пользователь нажал на кнопку «Сделать заказ» 
Логируем время, идентификатор покупателя, номер заказа
2. MES API — Создаем запись после подсчета стоимости заказа.  
Логируем время, идентификатор покупателя, номер заказа 
3. MES API — Создаем запись после того, как оператор взял заказ в работу.
Логируем время, идентификатор покупателя, номер заказа
4. MES API — Создаем запись после того, как оператор выполнил заказ 
Логируем время, идентификатор покупателя, номер заказа
5. MES API — Создаем запись после того, как заказ отправлен покупателю.
Логируем время, идентификатор покупателя, номер заказа
6. CRM - заказ завершён.
Логируем время, идентификатор покупателя, номер заказа

Необходимо собирать логи с типом WARN

1. 3d files storage - Необходимо создавать запись, когда остается меньше 1Gb свободного мест в хранилище
Логируем  время, имя хранилища, сколько свободного места осталось
2. Shop DB, MES DB - Необходимо создавать запись, когда остается меньше 1Gb свободного мест в инстансах где развернуты базы данных.
Логируем  время, имя базы данных, сколько свободного места осталось

Необходимо собрать логи с типом ERROR

Создаем логи данного типа во всех компонентах в случае ошибок при подключении:
1. К базам данных
Логируем  время, имя базы данных, операция создающая ошибку
2. К файловому хранилищу
Логируем  время, имя хранилища, операция создающая ошибку
3. К внутренним API других компонентов
Логируем  время, имя хранилища, конечная точка создающая ошибку

## Мотивация

1. Логирование делает более прозрачной процессы в системе, можно отследить состояние заказов, что положительно влияет на качество обслуживание клиентов
2. Логирование позволяет понять в каком месте произошли ошибки, тем самым мы быстрее сможем восстановить систему после сбоев, что позволит предотвратить негативную реакцию клиентов и уменьшение скорости работы заказов.
3. Логирование типа WARN позволяет предупредить ошибки, на которые можно своевременно отреагировать. 
4. Будущем на базе логов INFO можно с меньшими трудозатратами написать систему логировани, если планируется увеличение количества клиентов. Информация из логов служить базой для рассылки клиентам при изменении статусов заказа.

## Ограничения
В случае ограничения ресурсах, предлагаю следующим образом распределить использования трейсинга и логирования:
1. В системах, на которые не было жалоб со стороны внешних и внутренних пользователей (в нашем случае это Онлайн-магазин и CRM) оставить только логирование описанное выше
2. В системах где есть узкие места (MES), оставить логирование и трейсинг описанный в Exc3

## Предлагаемое решение
Для организации логирования планирую использовать стек ELK и Filebeat который содержит:
1. Filebeat устанавливается в компоненты, которым необходима настройка логирования
2. Logstash — это серверный конвейер обработки данных. Он собирает входные данные и отправляет их в OpenSearch
3. OpenSearch (аналог Elasticsearch)— это документоориентированная распределённая база данных NoSQL. Хранит сложные структуры данных, которые сериализованы в виде документов JSON
4. Kibana — это инструмент, который используют для визуализации документов OpenSearch

В компоненты описанные в разделе "Собираемые логи" мы встраиваем в Filebeat и собираем с него информацию. Решение подробно отображено на схеме красным в файле jewerly_c4_model_logs.drawio

## Политика хранения логов
Предлагаю создавать отдельный индекс под каждый компонента
По времени хранения:
1. Считаю, что логи типа ERROR и WARN необходимо хранить неделю с момента их фиксирования
2. Логи типа INFO храним до завершения заказа с определяющим его идентификатором 

## Мероприятия для превращения системы сбора логов в систему анализа логов
Предлагаю настроить алертинг на следующие события:
1. Анализ количества запросов к узлам Shop API и MES API. Сообщать если количество запросов превысило 10000
2. Анализ работы подключений. Сообщать если у компонента возникают ошибки подключения к базам данным, файловом хранилищу, Другим компонентам по API, очереди MQ
3. Сообщать о нехватке свободного места (в случае если у нас есть ограничение в облаке)

## Критерии выбора технологии
Делаем выбор на основе данных полученных из интернета и собранных в таблицу
|Критерий|ELK|OpenSerch|Splunk|
|-----------|-----------|-----------|-----------|
| Лицензии|Elastic License|Apache License, Version 2.0|Проприетарная|
|Тип данных|Неструктурированные, JSON, логи|Неструктурированные, JSON, логи|Логи, операционные данные|
|Масштабируемость|Высокая|Высокая|Ограниченная|
|Удобство|Среднее (требует настройки)|Среднее (проще в облаке)|Очень удобный|
|Безопасность|Средняя (лучше в платных версиях)|Высокая|Очень высокая|
|Производительность|Высокая|Высокая|Высокая для реального времени|

На основе данных сделан выбор в пользу OpenSerch, как наиболее оптимальной
