# Архитектурное решение по кешированию

## Анализ диаграммы
Проанализировав взаимодействие компонентов MES на диаграмме, вижу следующие варианты использования кеширования:
1. Использовать клиентское кеширование. Он позволит уменьшить время загрузки данных на фронтенд с MES API
2. Использовать серверноре кеширование для того, чтобы максимально быстро получать данные из MES DB

## Мотивация и возможные решения
Как альтернативу кешированию, можно рассмотреть следующие варианты:
1. разделение компонента MES API на 3 компонента - один из них будет заниматься исключительно расчетами, другой работой с операторами, третий взаимодействием с USER API операторами. Нагрузка распределится по разным компонентам, тем самым снизится нагрузка на компонент взаимодействующий с операторами. 
2. Масштабирование MES API при помощи Kubernatis. В зависимости от нагрузки, количество рабочих Pod будет увеличиваться и тем самым повышаем производительность.
3. Использование клиентского и серверного кеширования, описанного в "Анализ диаграммы"

На мой взгляд, использование кеширования позволит наиболее простым способом увеличить производительность компонента MES. Варианты 1 требует значительной доработки системы. Вариант 2 требует усложняет настройку системы и затраты на облачные сервисы

## Предполагаемое решение
Для клиентского кеширования предполагается использование настройки Cache-Control: no-cache
Если данные о заказах не менялись, система берет данные из кеш, если данные по заказам обновились, то необходимо обращаться к серверному кеш и на основе его результатов обновлять данные. Так как скорость возникновения новых заказов не большая, этот алгоритм позволит ускорить работу.

В случае чтения для серверного кеширования  предполагаем использование паттерна Refresh-ahead
Для нас основными преимуществом данного паттерна являются:
1. Низкая стоимость чтения данных из БД
2. Согласованность записей кеша, к которым часто обращаются пользователи

В нашем случае данные, к которым часто обращаются пользователи, это данные по заказам.  Именно они будут асинхронно обновляться 

В случае записи для серверного кеширования  предполагаем использование паттерна Write-Behind
Для нас основными преимуществом данного паттерна являются высокая скорость

Алгоритм работы этих шаблонов можно посмотреть PlantUML диаграмме последовательности в файлах sequence_diagram_rd.puml (чтение)
sequence_diagram_wr.puml(запись)

## Cтратегии инвалидации кеш
1. Для клиентского кеша используется способ "Инвалидация на основе изменений". При получении данных из базы, если данные отличаются от текущих данных кеш, они изменяются
2. Для серверного кеш используется способ "Инвалидация на основе изменений" для чтения и записи. При изменении данных в кеш создает задачу на асинхронное обновление базы.  

Сравнение с другими стратегиями кеширования
|Временная инвалидация|Инвалидация, основанная на запросах|Инвалидация на основе изменений|Программная инвалидация|Инвалидация по ключу|
|-----------|-----------|-----------|-----------|-----------|
| Данный способ не подходит, так как с ним в определенный момент времени могут возникнуть неактуальные данные|Данный способ мог бы подойти, но требуются дополнительные трудозатраты на выявление этих запросов|Этот способ подходит больше всего, критерием обновления является изменение данных|Данный способ мог бы подойти, но требуются дополнительные трудозатраты на его реализацию и изменение кода|Данный способ мог бы подойти, но требуются дополнительные трудозатраты для выявления ключей|

## Сравнение предполагаемых решений
Сравнение двух наиболее подходящих предполагаемых решений

||Решение1|Решение2|
|-----------|-----------|-----------|
| Описание решения|Масштабирование MES API при помощи Kubernatis. Диаграмма в файле jewerly_c4_model_sol1.drawio|Использование клиентского и серверного кеширования. Диаграмма в файле jewerly_c4_model_sol1.drawio|
| Плюсы|1. Позволяем масштабировать компонент и решить все проблемы его производительности 2. Повышает отказоустойчивость компонента|1. Увеличивает скорость работы с данными 2. Требует небольших трудозатрат по внедрению |
| Минусы|1. Требует больше трудозатрат по внедрению и обслуживанию 2. Не увеличивает скорость работы базы данных с компонентом| 1. Не решает проблем в случае перегрузки вычислительных мощностей при расчете заказов|
 
На первом этапе мы приняли "Решение2", так как это наиболее простой способ и менее затратный. Но в дальнейшем возможно совместить два этих решения. Использование Kubernatis (возможно другого решения по горизонтальному масштабированию) позволит решить проблемы с загрузкой мощностей при расчетах. Так же положительно повлияло бы создание дополнительной фильтрации по дате заказа( в условии про ее наличие не сказано), так как операторов больше интересуют последние заказы. Выдача только последних заказов - менее ресурсозатратный процесс.